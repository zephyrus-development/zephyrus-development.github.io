<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Zephyrus - Secure File Sharing</title>
    <meta property="og:title" content="Shared File via Zephyrus">
    <meta property="og:description" content="View securely shared file">
    <meta property="og:type" content="website">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', 'Cantarell', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        .container {
            background: white;
            border-radius: 12px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            max-width: 500px;
            width: 100%;
            padding: 40px;
            text-align: center;
        }

        .header {
            margin-bottom: 30px;
        }

        .logo {
            font-size: 48px;
            margin-bottom: 20px;
        }

        h1 {
            color: #333;
            margin-bottom: 10px;
            font-size: 28px;
        }

        .subtitle {
            color: #666;
            margin-bottom: 10px;
            font-size: 14px;
        }

        .status-box {
            background: #f5f5f5;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
            min-height: 80px;
            display: flex;
            flex-direction: column;
            justify-content: center;
        }

        .status-text {
            color: #666;
            font-size: 14px;
            margin-bottom: 10px;
        }

        .status-message {
            color: #333;
            font-size: 16px;
            font-weight: 500;
            word-break: break-word;
        }

        .progress-bar {
            width: 100%;
            height: 4px;
            background: #e0e0e0;
            border-radius: 2px;
            overflow: hidden;
            margin-top: 10px;
        }

        .progress-fill {
            height: 100%;
            background: #667eea;
            width: 0%;
            transition: width 0.3s ease;
        }

        .button-group {
            display: flex;
            gap: 10px;
            margin-top: 20px;
            flex-wrap: wrap;
            justify-content: center;
        }

        button {
            padding: 12px 20px;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .btn-primary:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(102, 126, 234, 0.3);
        }

        .btn-primary:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .btn-secondary {
            background: #f0f0f0;
            color: #333;
        }

        .btn-secondary:hover:not(:disabled) {
            background: #e0e0e0;
        }

        .error {
            color: #d32f2f;
            background: #ffebee;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            border-left: 4px solid #d32f2f;
        }

        .success {
            color: #388e3c;
            background: #e8f5e9;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            border-left: 4px solid #388e3c;
        }

        .info-box {
            background: #e3f2fd;
            color: #1565c0;
            padding: 15px;
            border-radius: 8px;
            font-size: 13px;
            margin-top: 20px;
            line-height: 1.5;
        }

        .spinner {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid #f3f3f3;
            border-top: 3px solid #667eea;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .file-name {
            font-family: 'Courier New', monospace;
            background: #f5f5f5;
            padding: 8px 12px;
            border-radius: 4px;
            margin: 10px 0;
            word-break: break-all;
        }

        .hidden {
            display: none;
        }


    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <div class="logo">üîê</div>
            <h1>Zephyrus Secure Sharing</h1>
            <p class="subtitle">Decrypting your shared file...</p>
        </div>

        <div id="errorBox" class="error hidden"></div>
        <div id="successBox" class="success hidden"></div>

        <div class="status-box">
            <div class="status-text">Status</div>
            <div class="status-message" id="statusMessage">
                <div class="spinner"></div> Preparing...
            </div>
            <div class="progress-bar">
                <div class="progress-fill" id="progressFill"></div>
            </div>
        </div>

        <div id="fileInfo" class="hidden">
            <div class="file-name" id="fileName"></div>
        </div>

        <div class="button-group">
            <button id="viewBtn" class="btn-primary hidden" onclick="viewFile()">
                üëÅÔ∏è View File
            </button>
            <button id="downloadBtn" class="btn-secondary hidden" onclick="downloadFile()">
                üì• Download File
            </button>
            <button id="retryBtn" class="btn-secondary hidden" onclick="location.reload()">
                üîÑ Retry
            </button>
        </div>

        <div class="info-box">
            <strong>üîí Privacy Notice:</strong><br>
            This file is decrypted entirely in your browser. Your file and password never leave your device.
        </div>
    </div>

    <script>
        const SALT_SIZE = 16;
        const NONCE_SIZE = 12;
        const ITERATIONS = 100000;

        let decryptedData = null;
        let fileName = null;
        let mimeType = 'application/octet-stream';

        async function main() {
            try {
                // Parse share string from URL hash
                const hash = window.location.hash.substring(1);
                if (!hash) {
                    throw new Error('No share string provided. Please use a share link.');
                }

                const parts = hash.split(':');
                if (parts.length < 3 || parts.length > 4) {
                    throw new Error('Invalid share string format.');
                }

                const username = parts[0];
                const reference = parts[1];
                const password = parts[2];
                let encodedFileName = parts[3];

                if (!username || !reference || !password) {
                    throw new Error('Invalid share string - missing components.');
                }

                // Decode filename if provided in share string
                if (encodedFileName) {
                    try {
                        const decodedBytes = Uint8Array.from(atob(encodedFileName), c => c.charCodeAt(0));
                        fileName = new TextDecoder().decode(decodedBytes);
                    } catch (e) {
                        console.warn('Could not decode filename:', e);
                        fileName = null;
                    }
                }

                updateStatus('Fetching share pointer...');
                setProgress(20);

                // Fetch the share pointer from GitHub
                const pointerUrl = `https://raw.githubusercontent.com/${username}/.zephyrus/master/shared/${reference}`;
                const pointerResponse = await fetch(pointerUrl);

                if (!pointerResponse.ok) {
                    throw new Error(`Failed to fetch share pointer (${pointerResponse.status}). File may not exist or reference may be incorrect.`);
                }

                const pointerBuffer = await pointerResponse.arrayBuffer();

                updateStatus('Decrypting share pointer...');
                setProgress(35);

                // Decrypt the pointer with the share password
                let decryptedPointer;
                try {
                    decryptedPointer = await decryptFile(pointerBuffer, password);
                } catch (e) {
                    throw new Error(`Failed to decrypt share pointer: ${e.message}`);
                }

                let pointerData;
                try {
                    const pointerText = new TextDecoder().decode(decryptedPointer);
                    pointerData = JSON.parse(pointerText);
                } catch (e) {
                    throw new Error(`Invalid pointer data: ${e.message}. Share may be corrupted or using old format.`);
                }

                if (!pointerData.storageID || !pointerData.fileKey) {
                    throw new Error('Invalid share pointer - missing storageID or fileKey.');
                }

                updateStatus('Fetching encrypted file...');
                setProgress(50);

                // Fetch the actual encrypted file using the storage ID from the pointer
                const fileUrl = `https://raw.githubusercontent.com/${username}/.zephyrus/master/${pointerData.storageID}`;
                const fileResponse = await fetch(fileUrl);

                if (!fileResponse.ok) {
                    throw new Error(`Failed to fetch file (${fileResponse.status}).`);
                }

                const encryptedFileBuffer = await fileResponse.arrayBuffer();

                updateStatus('Decrypting file...');
                setProgress(75);

                // The file key is stored as raw hex bytes in the pointer (not encrypted)
                let fileKey;
                try {
                    fileKey = hexToBuffer(pointerData.fileKey);
                    if (fileKey.length !== 32) {
                        throw new Error(`Invalid file key length: expected 32 bytes, got ${fileKey.length}`);
                    }
                } catch (e) {
                    throw new Error(`Failed to parse file key: ${e.message}`);
                }

                updateStatus('Decompressing file...');
                setProgress(90);

                // Decrypt the file content with the file key
                try {
                    decryptedData = await decryptFileWithKey(encryptedFileBuffer, fileKey);
                } catch (e) {
                    throw new Error(`Failed to decrypt file content: ${e.message}`);
                }

                updateStatus('File ready to view');
                setProgress(100);

                // Use provided filename or derive from reference
                if (!fileName) {
                    fileName = `zephyrus_file_${reference}.bin`;
                }

                // Determine MIME type from filename
                determineMimeType(fileName);

                document.getElementById('fileInfo').classList.remove('hidden');
                document.getElementById('fileName').textContent = fileName;

                document.getElementById('viewBtn').classList.remove('hidden');
                document.getElementById('downloadBtn').classList.remove('hidden');
                document.getElementById('statusMessage').innerHTML = '‚úÖ File decrypted successfully!';

                // Show success message
                const successBox = document.getElementById('successBox');
                successBox.textContent = 'File is ready to view or download. Click the button below to get started.';
                successBox.classList.remove('hidden');

            } catch (error) {
                console.error('Error:', error);
                updateStatus('Error: ' + error.message, true);
                document.getElementById('retryBtn').classList.remove('hidden');
            }
        }

        function determineMimeType(filename) {
            const ext = filename.toLowerCase().split('.').pop();
            const mimeTypes = {
                'txt': 'text/plain',
                'json': 'application/json',
                'html': 'text/html',
                'htm': 'text/html',
                'xml': 'application/xml',
                'csv': 'text/csv',
                'md': 'text/markdown',
                'js': 'application/javascript',
                'css': 'text/css',
                'pdf': 'application/pdf',
                'jpg': 'image/jpeg',
                'jpeg': 'image/jpeg',
                'png': 'image/png',
                'gif': 'image/gif',
                'webp': 'image/webp',
                'svg': 'image/svg+xml'
            };
            mimeType = mimeTypes[ext] || 'application/octet-stream';
        }

        async function decryptFile(encryptedData, password) {
            // Extract salt and nonce
            const view = new Uint8Array(encryptedData);
            const salt = view.slice(0, SALT_SIZE);
            const nonce = view.slice(SALT_SIZE, SALT_SIZE + NONCE_SIZE);
            const ciphertext = view.slice(SALT_SIZE + NONCE_SIZE);

            // Derive key using PBKDF2
            const keyMaterial = await window.crypto.subtle.importKey(
                'raw',
                new TextEncoder().encode(password),
                'PBKDF2',
                false,
                ['deriveBits']
            );

            const derivedBits = await window.crypto.subtle.deriveBits(
                {
                    name: 'PBKDF2',
                    salt: salt,
                    iterations: ITERATIONS,
                    hash: 'SHA-256'
                },
                keyMaterial,
                256
            );

            const key = await window.crypto.subtle.importKey(
                'raw',
                derivedBits,
                'AES-GCM',
                false,
                ['decrypt']
            );

            // Decrypt using AES-GCM
            const decrypted = await window.crypto.subtle.decrypt(
                {
                    name: 'AES-GCM',
                    iv: nonce
                },
                key,
                ciphertext
            );

            return new Uint8Array(decrypted);
        }

        async function decryptFileWithKey(encryptedData, keyBuffer) {
            // Format: [Nonce (12 bytes)][Ciphertext]
            // Note: No salt when using raw key (unlike PBKDF2 mode)
            const view = new Uint8Array(encryptedData);
            const nonce = view.slice(0, NONCE_SIZE);
            const ciphertext = view.slice(NONCE_SIZE);

            // Import the provided key directly (already 32 bytes of raw key material)
            const key = await window.crypto.subtle.importKey(
                'raw',
                keyBuffer,
                'AES-GCM',
                false,
                ['decrypt']
            );

            // Decrypt using AES-GCM
            const decrypted = await window.crypto.subtle.decrypt(
                {
                    name: 'AES-GCM',
                    iv: nonce
                },
                key,
                ciphertext
            );

            return new Uint8Array(decrypted);
        }

        function hexToBuffer(hexString) {
            // Convert hex string to Uint8Array
            const bytes = new Uint8Array(hexString.length / 2);
            for (let i = 0; i < hexString.length; i += 2) {
                bytes[i / 2] = parseInt(hexString.substr(i, 2), 16);
            }
            return bytes;
        }

        function updateStatus(message, isError = false) {
            const statusMessage = document.getElementById('statusMessage');
            statusMessage.textContent = message;

            if (isError) {
                const errorBox = document.getElementById('errorBox');
                errorBox.textContent = message;
                errorBox.classList.remove('hidden');
            }
        }

        function setProgress(percent) {
            document.getElementById('progressFill').style.width = percent + '%';
        }

        function viewFile() {
            if (!decryptedData) {
                alert('No file data available');
                return;
            }

            try {
                // Create a blob from the decrypted data
                const blob = new Blob([decryptedData], { type: mimeType });
                const url = window.URL.createObjectURL(blob);
                
                // Open in a new tab
                window.open(url, '_blank');
            } catch (e) {
                console.error('Could not open file:', e);
                alert('Failed to open file');
            }
        }

        function downloadFile() {
            if (!decryptedData) {
                alert('No file data available');
                return;
            }

            const blob = new Blob([decryptedData], { type: mimeType });
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = fileName || 'download';
            document.body.appendChild(a);
            a.click();
            window.URL.revokeObjectURL(url);
            document.body.removeChild(a);
        }

        // Start the process
        window.addEventListener('load', main);
    </script>
</body>
</html>
